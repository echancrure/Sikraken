Sikraken ./bin/call_parser.sh says: SIKRAKEN_INSTALL_DIR is /home/chris/Sikraken/bin/..
Sikraken parser in debug mode: parsing the file /home/chris/Sikraken/bin/../sikraken_output/parsing_bugs/parsing_bugs.i using 32 bits data model.
Pushed scope 0
add_typedef_id: Added __gnuc_va_list as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 1
is_typedef_name: Looking for MYINT in typedef list
Scope 0:
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found MYINT is a basic IDENTIFIER
Lexer FSM: checking id: MYINT with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=UC_MYINT
add_typedef_id: Added MYINT as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], int)
is_typedef_name: Looking for MYINT in typedef list
Scope 0:
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: MYINT with status 1 with FSM ON in mode UNKNOWN_VD_STATE 
is_typedef_name: Looking for myint in typedef list
Scope 0:
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found myint is a basic IDENTIFIER
Lexer FSM: checking id: myint with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=0, ptr_declarator=Myint
Debug: create_declaration_specifiers returned: spec([], UC_MYINT)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: table is a tag
end of stand alone declaration specifier as a declaration on line 3
Debug: create_declaration_specifiers returned: spec([], struct(Table))
Debug: typedef switched to 1
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: table is a tag
is_typedef_name: Looking for table in typedef list
Scope 0:
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found table is a basic IDENTIFIER
Lexer FSM: checking id: table with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
DEBUG: typedef_flag=1, ptr_declarator=Table
add_typedef_id: Added table as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], struct(Table))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: table is a tag
is_typedef_name: Looking for name in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found name is a basic IDENTIFIER
Lexer FSM: checking id: name with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: name on line 6
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for type in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found type is a basic IDENTIFIER
Lexer FSM: checking id: type with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: type on line 7
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for value in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found value is a basic IDENTIFIER
Lexer FSM: checking id: value with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: value on line 8
Debug: create_declaration_specifiers returned: spec([], int)
end of stand alone declaration specifier as a declaration on line 9
Debug: create_declaration_specifiers returned: spec([], struct(Table, [struct_decl(spec([], char), [ptr_decl(pointer, name)]), struct_decl(spec([], int), [type]), struct_decl(spec([], int), [value])]))
is_typedef_name: Looking for inSpecMode in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found inSpecMode is a basic IDENTIFIER
Lexer FSM: checking id: inSpecMode with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for table in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: table with status 1 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Pushed scope 1
add_typedef_id: Added table as a shadow IDENTIFIER to typedef list
Lexer Debug: declared the SHADOWING PARAMETER of a typedef_name: table on line 10
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=0, ptr_declarator=InSpecMode
Trying to Pop scope 1 when scope_stack scope_nb is 1
Popped scope 1
Warning: the 'static' storage specifier is always ignored by the parser because Sikraken does not support it yet
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for allocate_entry_120489 in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found allocate_entry_120489 is a basic IDENTIFIER
Lexer FSM: checking id: allocate_entry_120489 with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for table in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: table with status 1 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Pushed scope 1
add_typedef_id: Added table as a shadow IDENTIFIER to typedef list
Lexer Debug: declared the SHADOWING PARAMETER of a typedef_name: table on line 11
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=0, ptr_declarator=Allocate_entry_120489
Trying to Pop scope 1 when scope_stack scope_nb is 1
Popped scope 1
Warning: the 'static' storage specifier is always ignored by the parser because Sikraken does not support it yet
Debug: create_declaration_specifiers returned: spec([], int)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: inpcb is a tag
is_typedef_name: Looking for in_pcbffffffffffhashlookup in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found in_pcbffffffffffhashlookup is a basic IDENTIFIER
Lexer FSM: checking id: in_pcbffffffffffhashlookup with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: inpcbtable is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Inpcbtable))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: in_addr is a tag
Debug: create_declaration_specifiers returned: spec([], struct(In_addr))
Debug: create_declaration_specifiers returned: spec([], int)
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: in_addr is a tag
Debug: create_declaration_specifiers returned: spec([], struct(In_addr))
Debug: create_declaration_specifiers returned: spec([], int)
Debug: create_declaration_specifiers returned: spec([], int)
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=0, ptr_declarator=In_pcbffffffffffhashlookup
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], struct(Inpcb))
Debug: typedef switched to 1
is_typedef_name: Looking for __uint32_t in typedef list
Scope 0:
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __uint32_t is a basic IDENTIFIER
Lexer FSM: checking id: __uint32_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=UC___uint32_t
add_typedef_id: Added __uint32_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(int))
Debug: typedef switched to 1
is_typedef_name: Looking for __uint32_t in typedef list
Scope 0:
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: __uint32_t with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE 
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found u_int32_t is a basic IDENTIFIER
Lexer FSM: checking id: u_int32_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=U_int32_t
add_typedef_id: Added u_int32_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], UC___uint32_t)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: baddynamicports is a tag
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
is_typedef_name: Looking for tcp in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found tcp is a basic IDENTIFIER
Lexer FSM: checking id: tcp with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: tcp on line 17
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for udp in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found udp is a basic IDENTIFIER
Lexer FSM: checking id: udp with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: udp on line 19
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
is_typedef_name: Looking for u_int32_t in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: u_int32_t with status 1 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
Debug: create_declaration_specifiers returned: spec([], U_int32_t)
end of stand alone declaration specifier as a declaration on line 21
Debug: create_declaration_specifiers returned: spec([], struct(Baddynamicports, [struct_decl(spec([], U_int32_t), [array_decl(tcp, ((div_op((plus_op((int(65536)), (minus_op(((multiply_op(size_of_type(spec([], U_int32_t)), int(8)))), int(1))))), ((multiply_op(size_of_type(spec([], U_int32_t)), int(8))))))))]), struct_decl(spec([], U_int32_t), [array_decl(udp, ((div_op((plus_op((int(65536)), (minus_op(((multiply_op(size_of_type(spec([], U_int32_t)), int(8)))), int(1))))), ((multiply_op(size_of_type(spec([], U_int32_t)), int(8))))))))])]))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: baddynamicports is a tag
is_typedef_name: Looking for baddynamicports in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found baddynamicports is a basic IDENTIFIER
Lexer FSM: checking id: baddynamicports with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
DEBUG: typedef_flag=0, ptr_declarator=Baddynamicports
Debug: create_declaration_specifiers returned: spec([extern], struct(Baddynamicports))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: baddynamicports is a tag
is_typedef_name: Looking for rootonlyports in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found rootonlyports is a basic IDENTIFIER
Lexer FSM: checking id: rootonlyports with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
DEBUG: typedef_flag=0, ptr_declarator=Rootonlyports
Debug: create_declaration_specifiers returned: spec([extern], struct(Baddynamicports))
is_typedef_name: Looking for in_losing in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found in_losing is a basic IDENTIFIER
Lexer FSM: checking id: in_losing with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: inpcb is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Inpcb))
DEBUG: typedef_flag=0, ptr_declarator=In_losing
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for f in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found f is a basic IDENTIFIER
Lexer FSM: checking id: f with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for x0 in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x0 is a basic IDENTIFIER
Lexer FSM: checking id: x0 with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for a in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found a is a basic IDENTIFIER
Lexer FSM: checking id: a with status 0 with FSM OFF in mode UNKNOWN_VD_STATE 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for b in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found b is a basic IDENTIFIER
Lexer FSM: checking id: b with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for a in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found a is a basic IDENTIFIER
Lexer FSM: checking id: a with status 0 with FSM ON in mode UNKNOWN_VD_STATE 
is_typedef_name: Looking for b in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found b is a basic IDENTIFIER
Lexer FSM: checking id: b with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
Trying to Pop scope 2 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
function parsed
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: device is a tag
end of stand alone declaration specifier as a declaration on line 33
Debug: create_declaration_specifiers returned: spec([], struct(Device, []))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: A is a tag
is_typedef_name: Looking for a in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found a is a basic IDENTIFIER
Lexer FSM: checking id: a with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: a on line 35
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for b in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found b is a basic IDENTIFIER
Lexer FSM: checking id: b with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: b on line 36
Debug: create_declaration_specifiers returned: spec([], int)
end of stand alone declaration specifier as a declaration on line 37
Debug: create_declaration_specifiers returned: spec([], struct(UC_A, [struct_decl(spec([], int), [a]), struct_decl(spec([], int), [b])]))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: my_data is a tag
is_typedef_name: Looking for lock in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found lock is a basic IDENTIFIER
Lexer FSM: checking id: lock with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: lock on line 39
Debug: create_declaration_specifiers returned: spec([], int)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: device is a tag
is_typedef_name: Looking for dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found dev is a basic IDENTIFIER
Lexer FSM: checking id: dev with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
Debug: create_declaration_specifiers returned: spec([], struct(Device))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: A is a tag
is_typedef_name: Looking for shared in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found shared is a basic IDENTIFIER
Lexer FSM: checking id: shared with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
Debug: create_declaration_specifiers returned: spec([], struct(UC_A))
end of stand alone declaration specifier as a declaration on line 42
Debug: create_declaration_specifiers returned: spec([], struct(My_data, [struct_decl(spec([], int), [lock]), struct_decl(spec([], struct(Device)), [Dev]), struct_decl(spec([], struct(UC_A)), [Shared])]))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: device is a tag
is_typedef_name: Looking for my_dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_dev is a basic IDENTIFIER
Lexer FSM: checking id: my_dev with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=0, ptr_declarator=My_dev
Debug: create_declaration_specifiers returned: spec([], struct(Device))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: my_data is a tag
is_typedef_name: Looking for data in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found data is a basic IDENTIFIER
Lexer FSM: checking id: data with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=0, ptr_declarator=Data
Debug: create_declaration_specifiers returned: spec([], struct(My_data))
is_typedef_name: Looking for oso in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found oso is a basic IDENTIFIER
Lexer FSM: checking id: oso with status 0 with FSM ON in mode VD_VAR_DECL 
Lexer FSM: bypassing typedef_name check in mode VD_VAR_DECL: id: my_data is a tag
Debug: create_declaration_specifiers returned: spec([], struct(My_data))
is_typedef_name: Looking for dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found dev is a basic IDENTIFIER
Lexer FSM: checking id: dev with status 0 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for g in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found g is a basic IDENTIFIER
Lexer FSM: checking id: g with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for data in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found data is a basic IDENTIFIER
Lexer FSM: checking id: data with status 0 with FSM ON in mode UNKNOWN_VD_STATE 
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: my_data is a tag
is_typedef_name: Looking for dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found dev is a basic IDENTIFIER
Lexer FSM: checking id: dev with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
is_typedef_name: Looking for __mptr in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __mptr is a basic IDENTIFIER
Lexer FSM: checking id: __mptr with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for my_dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_dev is a basic IDENTIFIER
Lexer FSM: checking id: my_dev with status 0 with FSM OFF in mode VD_VAR_DECL 
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], typeof__expression(struct_pointer((cast(type_abstract_declarator_dummy1, int(0))), dev)))
Lexer FSM: bypassing typedef_name check in mode VD_NOT_VAR_DECL: id: my_data is a tag
is_typedef_name: Looking for __mptr in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __mptr is a basic IDENTIFIER
Lexer FSM: checking id: __mptr with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
Lexer FSM: bypassing typedef_name check in mode VD_NOT_VAR_DECL: id: my_data is a tag
Debug: create_declaration_specifiers returned: spec([], struct(My_data))
is_typedef_name: Looking for dev in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found dev is a basic IDENTIFIER
Lexer FSM: checking id: dev with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
Trying to Pop scope 2 when scope_stack scope_nb is 0
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
function parsed
Debug: typedef switched to 1
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found PVOID is a basic IDENTIFIER
Lexer FSM: checking id: PVOID with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=UC_PVOID
add_typedef_id: Added PVOID as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], void)
Debug: typedef switched to 1
is_typedef_name: Looking for PVOID2 in typedef list
Scope 0:
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found PVOID2 is a basic IDENTIFIER
Lexer FSM: checking id: PVOID2 with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=UC_PVOID2
add_typedef_id: Added PVOID2 as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], void)
is_typedef_name: Looking for NormalRoutine in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found NormalRoutine is a basic IDENTIFIER
Lexer FSM: checking id: NormalRoutine with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode UNKNOWN_PD_STATE 
is_typedef_name: Looking for NormalContext in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found NormalContext is a basic IDENTIFIER
Lexer FSM: checking id: NormalContext with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for SystemArgument1 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found SystemArgument1 is a basic IDENTIFIER
Lexer FSM: checking id: SystemArgument1 with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for SystemArgument2 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found SystemArgument2 is a basic IDENTIFIER
Lexer FSM: checking id: SystemArgument2 with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
DEBUG: typedef_flag=0, ptr_declarator=UC_NormalRoutine
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: _KAPC is a tag
is_typedef_name: Looking for RundownRoutine in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found RundownRoutine is a basic IDENTIFIER
Lexer FSM: checking id: RundownRoutine with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: RundownRoutine on line 53
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for x in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for NormalRoutine in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found NormalRoutine is a basic IDENTIFIER
Lexer FSM: checking id: NormalRoutine with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: NormalRoutine on line 54
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode UNKNOWN_PD_STATE 
is_typedef_name: Looking for NormalContext2 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found NormalContext2 is a basic IDENTIFIER
Lexer FSM: checking id: NormalContext2 with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for SystemArgument1 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found SystemArgument1 is a basic IDENTIFIER
Lexer FSM: checking id: SystemArgument1 with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for SystemArgument2 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found SystemArgument2 is a basic IDENTIFIER
Lexer FSM: checking id: SystemArgument2 with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for chris2 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found chris2 is a basic IDENTIFIER
Lexer FSM: checking id: chris2 with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: chris2 on line 55
is_typedef_name: Looking for PVOID2 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID2 with status 1 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], UC_PVOID2)
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for PVOID in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: PVOID with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for NormalContext3 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found NormalContext3 is a basic IDENTIFIER
Lexer FSM: checking id: NormalContext3 with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: NormalContext3 on line 56
Debug: create_declaration_specifiers returned: spec([], UC_PVOID)
end of stand alone declaration specifier as a declaration on line 57
Debug: create_declaration_specifiers returned: spec([], struct(UC__KAPC, [struct_decl(spec([], void), [function(ptr_decl(pointer, RundownRoutine), [param(spec([], int), X)])]), struct_decl(spec([], void), [function(ptr_decl(pointer, NormalRoutine), [param(spec([], UC_PVOID), UC_NormalContext2), param(spec([], UC_PVOID), UC_SystemArgument1), param(spec([], UC_PVOID), UC_SystemArgument2)])]), struct_decl(spec([], int), [array_decl(chris2, size_of_type(spec([], UC_PVOID2)))]), struct_decl(spec([], UC_PVOID), [NormalContext3])]))
is_typedef_name: Looking for tl_last_error in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found tl_last_error is a basic IDENTIFIER
Lexer FSM: checking id: tl_last_error with status 0 with FSM ON in mode VD_VAR_DECL 
Warning: the 'static' storage specifier is always ignored by the parser because Sikraken does not support it yet
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for aws_raise_error_private in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found aws_raise_error_private is a basic IDENTIFIER
Lexer FSM: checking id: aws_raise_error_private with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for err in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found err is a basic IDENTIFIER
Lexer FSM: checking id: err with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for tl_last_error in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found tl_last_error is a basic IDENTIFIER
Lexer FSM: checking id: tl_last_error with status 0 with FSM ON in mode UNKNOWN_VD_STATE 
is_typedef_name: Looking for err in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found err is a basic IDENTIFIER
Lexer FSM: checking id: err with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], void)
function parsed
is_typedef_name: Looking for x in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for p in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found p is a basic IDENTIFIER
Lexer FSM: checking id: p with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for x in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for pp in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found pp is a basic IDENTIFIER
Lexer FSM: checking id: pp with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for p in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found p is a basic IDENTIFIER
Lexer FSM: checking id: p with status 0 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for __VERIFIER_nondet_int in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __VERIFIER_nondet_int is a basic IDENTIFIER
Lexer FSM: checking id: __VERIFIER_nondet_int with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
DEBUG: typedef_flag=0, ptr_declarator=UC___VERIFIER_nondet_int
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([extern], int)
Debug: typedef switched to 1
is_typedef_name: Looking for my_int56 in typedef list
Scope 0:
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_int56 is a basic IDENTIFIER
Lexer FSM: checking id: my_int56 with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=My_int56
add_typedef_id: Added my_int56 as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], int)
is_typedef_name: Looking for my_f in typedef list
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_f is a basic IDENTIFIER
Lexer FSM: checking id: my_f with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
Debug: create_declaration_specifiers returned: spec([], void)
Debug: typedef switched to 1
is_typedef_name: Looking for my_int56 in typedef list
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: my_int56 with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE 
is_typedef_name: Looking for MyFuncPtr in typedef list
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found MyFuncPtr is a basic IDENTIFIER
Lexer FSM: checking id: MyFuncPtr with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=1, ptr_declarator=UC_MyFuncPtr
Pushed scope 1
add_typedef_id: Added MyFuncPtr as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], My_int56)
Debug: typedef switched to 1
is_typedef_name: Looking for my_int56 in typedef list
Scope 1:
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: my_int56 with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE 
is_typedef_name: Looking for MyFuncPtr_Pointer in typedef list
Scope 1:
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found MyFuncPtr_Pointer is a basic IDENTIFIER
Lexer FSM: checking id: MyFuncPtr_Pointer with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=1, ptr_declarator=UC_MyFuncPtr_Pointer
add_typedef_id: Added MyFuncPtr_Pointer as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], My_int56)
is_typedef_name: Looking for my_int56 in typedef list
Scope 1:
	MyFuncPtr_Pointer is a TYPEDEF_NAME
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: my_int56 with status 1 with FSM ON in mode UNKNOWN_VD_STATE 
is_typedef_name: Looking for my_callback_ptr in typedef list
Scope 1:
	MyFuncPtr_Pointer is a TYPEDEF_NAME
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_callback_ptr is a basic IDENTIFIER
Lexer FSM: checking id: my_callback_ptr with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 2 before a list of parameters
Debug: create_declaration_specifiers returned: spec([], void)
DEBUG: typedef_flag=0, ptr_declarator=My_callback_ptr
Trying to Pop scope 2 when scope_stack scope_nb is 1
Debug: create_declaration_specifiers returned: spec([], My_int56)
is_typedef_name: Looking for my_int56 in typedef list
Scope 1:
	MyFuncPtr_Pointer is a TYPEDEF_NAME
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: my_int56 with status 1 with FSM ON in mode VD_VAR_DECL 
add_typedef_id: Added my_int56 as a shadow IDENTIFIER to typedef list
Lexer Debug: declared the SHADOWING IDENTIFIER of a typedef_name: my_int56 on line 71
the current_scope has just been increased to 2 before a list of parameters
is_typedef_name: Looking for x in typedef list
Scope 1:
	my_int56 is a shadow IDENTIFIER
	MyFuncPtr_Pointer is a TYPEDEF_NAME
	MyFuncPtr is a TYPEDEF_NAME
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=0, ptr_declarator=My_int56
Trying to Pop scope 2 when scope_stack scope_nb is 1
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 1
Popped scope 1
Debug: create_declaration_specifiers returned: spec([], void)
function parsed
Debug: typedef switched to 1
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found umode_t is a basic IDENTIFIER
Lexer FSM: checking id: umode_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=Umode_t
add_typedef_id: Added umode_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(short))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: kobject is a tag
end of stand alone declaration specifier as a declaration on line 74
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: attribute is a tag
is_typedef_name: Looking for name in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found name is a basic IDENTIFIER
Lexer FSM: checking id: name with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: name on line 76
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for mode in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found mode is a basic IDENTIFIER
Lexer FSM: checking id: mode with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: mode on line 77
Debug: create_declaration_specifiers returned: spec([], Umode_t)
end of stand alone declaration specifier as a declaration on line 78
Debug: create_declaration_specifiers returned: spec([], struct(Attribute, [struct_decl(spec([], char), [ptr_decl(pointer, name)]), struct_decl(spec([], Umode_t), [mode])]))
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE 
is_typedef_name: Looking for is_visible in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found is_visible is a basic IDENTIFIER
Lexer FSM: checking id: is_visible with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], int)
DEBUG: typedef_flag=0, ptr_declarator=Is_visible
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: attribute_group is a tag
is_typedef_name: Looking for name in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found name is a basic IDENTIFIER
Lexer FSM: checking id: name with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: name on line 81
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for is_visible in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found is_visible is a basic IDENTIFIER
Lexer FSM: checking id: is_visible with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: is_visible on line 82
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: attribute is a tag
is_typedef_name: Looking for attrs in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found attrs is a basic IDENTIFIER
Lexer FSM: checking id: attrs with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
end of stand alone declaration specifier as a declaration on line 84
Debug: create_declaration_specifiers returned: spec([], struct(Attribute_group, [struct_decl(spec([], char), [ptr_decl(pointer, name)]), struct_decl(spec([], Umode_t), [function(ptr_decl(pointer, is_visible), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], int), [])])]), struct_decl(spec([], struct(Attribute)), [ptr_decl(pointer(pointer, pointer), Attrs)])]))
Debug: typedef switched to 1
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found size_t is a basic IDENTIFIER
Lexer FSM: checking id: size_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=Size_t
add_typedef_id: Added size_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(long))
Debug: typedef switched to 1
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found ssize_t is a basic IDENTIFIER
Lexer FSM: checking id: ssize_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=Ssize_t
add_typedef_id: Added ssize_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], long)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: sysfs_ops is a tag
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ssize_t with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
is_typedef_name: Looking for show in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found show is a basic IDENTIFIER
Lexer FSM: checking id: show with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: show on line 88
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], char)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Ssize_t)
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ssize_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for store in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found store is a basic IDENTIFIER
Lexer FSM: checking id: store with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: store on line 89
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: size_t with status 1 with FSM ON in mode PD_UNNAMED_PARAMETERS 
Debug: create_declaration_specifiers returned: spec([], Size_t)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Ssize_t)
is_typedef_name: Looking for namespace in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found namespace is a basic IDENTIFIER
Lexer FSM: checking id: namespace with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: namespace on line 90
the current_scope has just been increased to 1 before a list of parameters
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode PD_UNNAMED_PARAMETERS: id: attribute is a tag
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Trying to Pop scope 1 when scope_stack scope_nb is 0
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], void)
end of stand alone declaration specifier as a declaration on line 91
Debug: create_declaration_specifiers returned: spec([], struct(Sysfs_ops, [struct_decl(spec([], Ssize_t), [function(ptr_decl(pointer, show), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], char), dummy_abstract_declarator)])]), struct_decl(spec([], Ssize_t), [function(ptr_decl(pointer, store), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], char), dummy_abstract_declarator), unnamed_param(spec([], Size_t), [])])]), struct_decl(spec([], void), [ptr_decl(pointer, function(ptr_decl(pointer, namespace), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator)]))])]))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table is a tag
end of stand alone declaration specifier as a declaration on line 92
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
Debug: typedef switched to 1
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table is a tag
is_typedef_name: Looking for ctl_table in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found ctl_table is a basic IDENTIFIER
Lexer FSM: checking id: ctl_table with status 0 with FSM ON in mode VD_WAIT_VAR_TYPE (in member namespace)
DEBUG: typedef_flag=1, ptr_declarator=Ctl_table
add_typedef_id: Added ctl_table as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], struct(Ctl_table))
Debug: typedef switched to 1
is_typedef_name: Looking for loff_t in typedef list
Scope 0:
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found loff_t is a basic IDENTIFIER
Lexer FSM: checking id: loff_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=Loff_t
add_typedef_id: Added loff_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], long_long)
Debug: typedef switched to 1
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found proc_handler is a basic IDENTIFIER
Lexer FSM: checking id: proc_handler with status 0 with FSM ON in mode VD_VAR_DECL 
Lexer FSM: bypassing typedef_name check in mode PD_WAIT_PARAM_TYPE: id: ctl_table is a tag
is_typedef_name: Looking for ctl in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found ctl is a basic IDENTIFIER
Lexer FSM: checking id: ctl with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for write in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found write is a basic IDENTIFIER
Lexer FSM: checking id: write with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for buffer in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found buffer is a basic IDENTIFIER
Lexer FSM: checking id: buffer with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: size_t with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for lenp in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found lenp is a basic IDENTIFIER
Lexer FSM: checking id: lenp with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], Size_t)
is_typedef_name: Looking for loff_t in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: loff_t with status 1 with FSM ON in mode PD_WAIT_NAMED_PARAM_TYPE 
is_typedef_name: Looking for ppos in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found ppos is a basic IDENTIFIER
Lexer FSM: checking id: ppos with status 0 with FSM ON in mode PD_PARAM_DECL 
Debug: create_declaration_specifiers returned: spec([], Loff_t)
DEBUG: typedef_flag=1, ptr_declarator=Proc_handler
add_typedef_id: Added proc_handler as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], int)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table is a tag
is_typedef_name: Looking for procname in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found procname is a basic IDENTIFIER
Lexer FSM: checking id: procname with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: procname on line 97
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for data in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found data is a basic IDENTIFIER
Lexer FSM: checking id: data with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: data on line 98
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for maxlen in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found maxlen is a basic IDENTIFIER
Lexer FSM: checking id: maxlen with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: maxlen on line 99
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for mode in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found mode is a basic IDENTIFIER
Lexer FSM: checking id: mode with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: mode on line 100
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table is a tag
is_typedef_name: Looking for child in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found child is a basic IDENTIFIER
Lexer FSM: checking id: child with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: proc_handler with status 1 with FSM ON in mode UNKNOWN_VD_STATE (in member namespace)
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: proc_handler with status 1 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: proc_handler on line 102
Debug: create_declaration_specifiers returned: spec([], Proc_handler)
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table_poll is a tag
is_typedef_name: Looking for poll in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found poll is a basic IDENTIFIER
Lexer FSM: checking id: poll with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table_poll))
is_typedef_name: Looking for extra1 in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found extra1 is a basic IDENTIFIER
Lexer FSM: checking id: extra1 with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: extra1 on line 104
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for extra2 in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found extra2 is a basic IDENTIFIER
Lexer FSM: checking id: extra2 with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: extra2 on line 105
Debug: create_declaration_specifiers returned: spec([], void)
end of stand alone declaration specifier as a declaration on line 106
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table, [struct_decl(spec([], char), [ptr_decl(pointer, procname)]), struct_decl(spec([], void), [ptr_decl(pointer, data)]), struct_decl(spec([], int), [maxlen]), struct_decl(spec([], Umode_t), [mode]), struct_decl(spec([], struct(Ctl_table)), [ptr_decl(pointer, Child)]), struct_decl(spec([], Proc_handler), [ptr_decl(pointer, proc_handler)]), struct_decl(spec([], struct(Ctl_table_poll)), [ptr_decl(pointer, Poll)]), struct_decl(spec([], void), [ptr_decl(pointer, extra1)]), struct_decl(spec([], void), [ptr_decl(pointer, extra2)])]))
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: __anonstruct____missing_field_name_212 is a tag
Lexer FSM: bypassing typedef_name check in mode VD_WAIT_VAR_TYPE: id: ctl_table is a tag
is_typedef_name: Looking for ctl_table in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ctl_table with status 1 with FSM ON in mode VD_VAR_DECL 
add_typedef_id: Added ctl_table as a shadow IDENTIFIER to typedef list
Lexer Debug: declared the SHADOWING IDENTIFIER of a typedef_name: ctl_table on line 108
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for used in typedef list
Scope 0:
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found used is a basic IDENTIFIER
Lexer FSM: checking id: used with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: used on line 109
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for count in typedef list
Scope 0:
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found count is a basic IDENTIFIER
Lexer FSM: checking id: count with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: count on line 110
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for nreg in typedef list
Scope 0:
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found nreg is a basic IDENTIFIER
Lexer FSM: checking id: nreg with status 0 with FSM ON in mode VD_VAR_DECL (in member namespace)
direct_declarator: in member namespace: nreg on line 111
Debug: create_declaration_specifiers returned: spec([], int)
end of stand alone declaration specifier as a declaration on line 112
Debug: create_declaration_specifiers returned: spec([], struct(UC___anonstruct____missing_field_name_212, [struct_decl(spec([], struct(Ctl_table)), [ptr_decl(pointer, Ctl_table)]), struct_decl(spec([], int), [used]), struct_decl(spec([], int), [count]), struct_decl(spec([], int), [nreg])]))
Debug: typedef switched to 1
is_typedef_name: Looking for __gnuc_va_list in typedef list
Scope 0:
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: __gnuc_va_list with status 1 with FSM ON in mode VD_VAR_DECL 
add_typedef_id: Added __gnuc_va_list as a shadow IDENTIFIER to typedef list
Lexer Debug: declared the SHADOWING IDENTIFIER of a typedef_name: __gnuc_va_list on line 113
DEBUG: typedef_flag=1, ptr_declarator=UC___gnuc_va_list
add_typedef_id: Added __gnuc_va_list as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
decl_spec_stack->decl_spec.atomic.typeName is va_list
Debug: create_declaration_specifiers returned: spec([typedef], va_list)
Debug: typedef switched to 1
is_typedef_name: Looking for __uint64_t in typedef list
Scope 0:
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __uint64_t is a basic IDENTIFIER
Lexer FSM: checking id: __uint64_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=UC___uint64_t
add_typedef_id: Added __uint64_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(long))
Debug: typedef switched to 1
is_typedef_name: Looking for __uint64_t in typedef list
Scope 0:
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: __uint64_t with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE 
is_typedef_name: Looking for uint64_t in typedef list
Scope 0:
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found uint64_t is a basic IDENTIFIER
Lexer FSM: checking id: uint64_t with status 0 with FSM ON in mode VD_VAR_DECL 
DEBUG: typedef_flag=1, ptr_declarator=Uint64_t
add_typedef_id: Added uint64_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], UC___uint64_t)
Debug: typedef switched to 1
is_typedef_name: Looking for uint64_t in typedef list
Scope 0:
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: uint64_t with status 1 with FSM ON in mode VD_WAIT_VAR_TYPE 
is_typedef_name: Looking for aws_hash_fn in typedef list
Scope 0:
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found aws_hash_fn is a basic IDENTIFIER
Lexer FSM: checking id: aws_hash_fn with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for key in typedef list
Scope 0:
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found key is a basic IDENTIFIER
Lexer FSM: checking id: key with status 0 with FSM ON in mode PD_DECIDE_PARAM_KIND 
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], void)
DEBUG: typedef_flag=1, ptr_declarator=Aws_hash_fn
add_typedef_id: Added aws_hash_fn as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], Uint64_t)
is_typedef_name: Looking for my_func in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found my_func is a basic IDENTIFIER
Lexer FSM: checking id: my_func with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], int)
function parsed
is_typedef_name: Looking for main in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found main is a basic IDENTIFIER
Lexer FSM: checking id: main with status 0 with FSM ON in mode VD_VAR_DECL 
the current_scope has just been increased to 1 before a list of parameters
is_typedef_name: Looking for v in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found v is a basic IDENTIFIER
Lexer FSM: checking id: v with status 0 with FSM ON in mode VD_VAR_DECL 
is_typedef_name: Looking for __VERIFIER_nondet_int in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found __VERIFIER_nondet_int is a basic IDENTIFIER
Lexer FSM: checking id: __VERIFIER_nondet_int with status 0 with FSM OFF in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for x in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode VD_VAR_DECL 
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for v in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found v is a basic IDENTIFIER
Lexer FSM: checking id: v with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
is_typedef_name: Looking for x in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode VD_NOT_VAR_DECL 
is_typedef_name: Looking for x in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode UNKNOWN_VD_STATE 
Trying to Pop scope 2 when scope_stack scope_nb is 0
is_typedef_name: Looking for x in typedef list
Scope 0:
	aws_hash_fn is a TYPEDEF_NAME
	uint64_t is a TYPEDEF_NAME
	__uint64_t is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
	__gnuc_va_list is a shadow IDENTIFIER
	ctl_table is a shadow IDENTIFIER
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
	my_int56 is a TYPEDEF_NAME
	PVOID2 is a TYPEDEF_NAME
	PVOID is a TYPEDEF_NAME
	u_int32_t is a TYPEDEF_NAME
	__uint32_t is a TYPEDEF_NAME
	table is a TYPEDEF_NAME
	MYINT is a TYPEDEF_NAME
	__gnuc_va_list is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 with FSM ON in mode UNKNOWN_VD_STATE 
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], int)
function parsed
Sikraken from ./bin/call_parser.sh: successfully preprocessed parsing_bugs and ran sikraken_parser.
