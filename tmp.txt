Sikraken ./bin/call_parser.sh says: SIKRAKEN_INSTALL_DIR is /home/chris/Sikraken/bin/..
Sikraken parser in debug mode: parsing the file /home/chris/Sikraken/bin/../sikraken_output/parsing_bugs/parsing_bugs.i.i using 32 bits data model.
is_typedef_name: Looking for __VERIFIER_nondet_int in typedef list
Scope stack is empty
is_typedef_name: not found __VERIFIER_nondet_int is a basic IDENTIFIER
Lexer FSM: checking id: __VERIFIER_nondet_int with status 0 in mode DM_SPECS
Trying to Pop scope 1 on empty scope_stack
DEBUG: typedef_flag=0, ptr_declarator=UC___VERIFIER_nondet_int
Debug: create_declaration_specifiers returned: spec([extern], int)
Debug: typedef switched to 1
is_typedef_name: Looking for umode_t in typedef list
Scope stack is empty
is_typedef_name: not found umode_t is a basic IDENTIFIER
Lexer FSM: checking id: umode_t with status 0 in mode DM_SPECS
DEBUG: typedef_flag=1, ptr_declarator=Umode_t
Pushed scope 0
add_typedef_id: Added umode_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(short))
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: kobject is a tag
end of stand alone declaration specifier as a declaration on line 3
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: attribute is a tag
is_typedef_name: Looking for name in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found name is a basic IDENTIFIER
Lexer FSM: checking id: name with status 0 in mode DM_DECLS
direct_declarator: in member namespace: name on line 5
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 in mode DM_NONE
is_typedef_name: Looking for mode in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found mode is a basic IDENTIFIER
Lexer FSM: checking id: mode with status 0 in mode DM_SPECS
direct_declarator: in member namespace: mode on line 6
Debug: create_declaration_specifiers returned: spec([], Umode_t)
end of stand alone declaration specifier as a declaration on line 7
Debug: create_declaration_specifiers returned: spec([], struct(Attribute, [struct_decl(spec([], char), [ptr_decl(pointer, name)]), struct_decl(spec([], Umode_t), [mode])]))
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 in mode DM_NONE
is_typedef_name: Looking for is_visible in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found is_visible is a basic IDENTIFIER
Lexer FSM: checking id: is_visible with status 0 in mode DM_DECLS
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 0
DEBUG: typedef_flag=0, ptr_declarator=Is_visible
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: attribute_group is a tag
is_typedef_name: Looking for name in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found name is a basic IDENTIFIER
Lexer FSM: checking id: name with status 0 in mode DM_DECLS
direct_declarator: in member namespace: name on line 10
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 in mode DM_NONE
is_typedef_name: Looking for is_visible in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found is_visible is a basic IDENTIFIER
Lexer FSM: checking id: is_visible with status 0 in mode DM_DECLS
direct_declarator: in member namespace: is_visible on line 11
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], int)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: attribute is a tag
is_typedef_name: Looking for attrs in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found attrs is a basic IDENTIFIER
Lexer FSM: checking id: attrs with status 0 in mode DM_DECLS
direct_declarator: in member namespace: attrs on line 12
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
end of stand alone declaration specifier as a declaration on line 13
Debug: create_declaration_specifiers returned: spec([], struct(Attribute_group, [struct_decl(spec([], char), [ptr_decl(pointer, name)]), struct_decl(spec([], Umode_t), [function(ptr_decl(pointer, is_visible), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], int), [])])]), struct_decl(spec([], struct(Attribute)), [ptr_decl(pointer(pointer, pointer), attrs)])]))
Debug: typedef switched to 1
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found size_t is a basic IDENTIFIER
Lexer FSM: checking id: size_t with status 0 in mode DM_SPECS
DEBUG: typedef_flag=1, ptr_declarator=Size_t
add_typedef_id: Added size_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], unsigned(long))
Debug: typedef switched to 1
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found ssize_t is a basic IDENTIFIER
Lexer FSM: checking id: ssize_t with status 0 in mode DM_SPECS
DEBUG: typedef_flag=1, ptr_declarator=Ssize_t
add_typedef_id: Added ssize_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], long)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: sysfs_ops is a tag
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ssize_t with status 1 in mode DM_NONE
is_typedef_name: Looking for show in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found show is a basic IDENTIFIER
Lexer FSM: checking id: show with status 0 in mode DM_DECLS
direct_declarator: in member namespace: show on line 17
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Debug: create_declaration_specifiers returned: spec([], char)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Ssize_t)
is_typedef_name: Looking for ssize_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ssize_t with status 1 in mode DM_NONE
is_typedef_name: Looking for store in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found store is a basic IDENTIFIER
Lexer FSM: checking id: store with status 0 in mode DM_DECLS
direct_declarator: in member namespace: store on line 18
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: attribute is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: size_t with status 1 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], Size_t)
Trying to Pop scope 1 when scope_stack scope_nb is 0
Debug: create_declaration_specifiers returned: spec([], Ssize_t)
is_typedef_name: Looking for namespace in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found namespace is a basic IDENTIFIER
Lexer FSM: checking id: namespace with status 0 in mode DM_DECLS
direct_declarator: in member namespace: namespace on line 19
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: kobject is a tag
Debug: create_declaration_specifiers returned: spec([], struct(Kobject))
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: attribute is a tag
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], struct(Attribute))
Trying to Pop scope 1 when scope_stack scope_nb is 0
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], void)
end of stand alone declaration specifier as a declaration on line 20
Debug: create_declaration_specifiers returned: spec([], struct(Sysfs_ops, [struct_decl(spec([], Ssize_t), [function(ptr_decl(pointer, show), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], char), dummy_abstract_declarator)])]), struct_decl(spec([], Ssize_t), [function(ptr_decl(pointer, store), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator), unnamed_param(spec([], char), dummy_abstract_declarator), unnamed_param(spec([], Size_t), [])])]), struct_decl(spec([], void), [ptr_decl(pointer, function(ptr_decl(pointer, namespace), [unnamed_param(spec([], struct(Kobject)), dummy_abstract_declarator), unnamed_param(spec([], struct(Attribute)), dummy_abstract_declarator)]))])]))
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table is a tag
end of stand alone declaration specifier as a declaration on line 21
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
Debug: typedef switched to 1
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table is a tag
is_typedef_name: Looking for ctl_table in typedef list
Scope 0:
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found ctl_table is a basic IDENTIFIER
Lexer FSM: checking id: ctl_table with status 0 in mode DM_NONE
DEBUG: typedef_flag=1, ptr_declarator=Ctl_table
add_typedef_id: Added ctl_table as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], struct(Ctl_table))
Debug: typedef switched to 1
is_typedef_name: Looking for loff_t in typedef list
Scope 0:
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found loff_t is a basic IDENTIFIER
Lexer FSM: checking id: loff_t with status 0 in mode DM_SPECS
DEBUG: typedef_flag=1, ptr_declarator=Loff_t
add_typedef_id: Added loff_t as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], long_long)
Debug: typedef switched to 1
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found proc_handler is a basic IDENTIFIER
Lexer FSM: checking id: proc_handler with status 0 in mode DM_SPECS
Lexer FSM: bypassing typedef_name check in mode DM_DECLS: id: ctl_table is a tag
is_typedef_name: Looking for ctl in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found ctl is a basic IDENTIFIER
Lexer FSM: checking id: ctl with status 0 in mode DM_SPECS
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for write in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found write is a basic IDENTIFIER
Lexer FSM: checking id: write with status 0 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for buffer in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found buffer is a basic IDENTIFIER
Lexer FSM: checking id: buffer with status 0 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for size_t in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: size_t with status 1 in mode DM_DECLS
is_typedef_name: Looking for lenp in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found lenp is a basic IDENTIFIER
Lexer FSM: checking id: lenp with status 0 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], Size_t)
is_typedef_name: Looking for loff_t in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: loff_t with status 1 in mode DM_DECLS
is_typedef_name: Looking for ppos in typedef list
Scope 0:
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found ppos is a basic IDENTIFIER
Lexer FSM: checking id: ppos with status 0 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], Loff_t)
Trying to Pop scope 1 when scope_stack scope_nb is 0
DEBUG: typedef_flag=1, ptr_declarator=Proc_handler
add_typedef_id: Added proc_handler as a TYPEDEF_NAME to typedef list
Debug: typedef switched to 0
Debug: create_declaration_specifiers returned: spec([typedef], int)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table is a tag
is_typedef_name: Looking for procname in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found procname is a basic IDENTIFIER
Lexer FSM: checking id: procname with status 0 in mode DM_DECLS
direct_declarator: in member namespace: procname on line 26
Warning: the 'const' qualifier is always ignored by the parser because it has no impact on symbolic execution
Debug: create_declaration_specifiers returned: spec([], char)
is_typedef_name: Looking for data in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found data is a basic IDENTIFIER
Lexer FSM: checking id: data with status 0 in mode DM_DECLS
direct_declarator: in member namespace: data on line 27
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for maxlen in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found maxlen is a basic IDENTIFIER
Lexer FSM: checking id: maxlen with status 0 in mode DM_SPECS
direct_declarator: in member namespace: maxlen on line 28
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for umode_t in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: umode_t with status 1 in mode DM_NONE
is_typedef_name: Looking for mode in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found mode is a basic IDENTIFIER
Lexer FSM: checking id: mode with status 0 in mode DM_SPECS
direct_declarator: in member namespace: mode on line 29
Debug: create_declaration_specifiers returned: spec([], Umode_t)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table is a tag
is_typedef_name: Looking for child in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found child is a basic IDENTIFIER
Lexer FSM: checking id: child with status 0 in mode DM_SPECS
direct_declarator: in member namespace: child on line 30
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: proc_handler with status 1 in mode DM_NONE
is_typedef_name: Looking for proc_handler in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: proc_handler with status 1 in mode DM_DECLS
direct_declarator: in member namespace: proc_handler on line 31
Debug: create_declaration_specifiers returned: spec([], Proc_handler)
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table_poll is a tag
is_typedef_name: Looking for poll in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found poll is a basic IDENTIFIER
Lexer FSM: checking id: poll with status 0 in mode DM_SPECS
direct_declarator: in member namespace: poll on line 32
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table_poll))
is_typedef_name: Looking for extra1 in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found extra1 is a basic IDENTIFIER
Lexer FSM: checking id: extra1 with status 0 in mode DM_DECLS
direct_declarator: in member namespace: extra1 on line 33
Debug: create_declaration_specifiers returned: spec([], void)
is_typedef_name: Looking for extra2 in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found extra2 is a basic IDENTIFIER
Lexer FSM: checking id: extra2 with status 0 in mode DM_DECLS
direct_declarator: in member namespace: extra2 on line 34
Debug: create_declaration_specifiers returned: spec([], void)
end of stand alone declaration specifier as a declaration on line 35
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table, [struct_decl(spec([], char), [ptr_decl(pointer, procname)]), struct_decl(spec([], void), [ptr_decl(pointer, data)]), struct_decl(spec([], int), [maxlen]), struct_decl(spec([], Umode_t), [mode]), struct_decl(spec([], struct(Ctl_table)), [ptr_decl(pointer, child)]), struct_decl(spec([], Proc_handler), [ptr_decl(pointer, proc_handler)]), struct_decl(spec([], struct(Ctl_table_poll)), [ptr_decl(pointer, poll)]), struct_decl(spec([], void), [ptr_decl(pointer, extra1)]), struct_decl(spec([], void), [ptr_decl(pointer, extra2)])]))
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: __anonstruct____missing_field_name_212 is a tag
Lexer FSM: bypassing typedef_name check in mode DM_SPECS: id: ctl_table is a tag
is_typedef_name: Looking for ctl_table in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: a matching id has been found it is a TYPEDEF_NAME
Lexer FSM: checking id: ctl_table with status 1 in mode DM_SPECS
Lexer Debug: peek found: ;
direct_declarator: in member namespace: ctl_table on line 37
Debug: create_declaration_specifiers returned: spec([], struct(Ctl_table))
is_typedef_name: Looking for used in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found used is a basic IDENTIFIER
Lexer FSM: checking id: used with status 0 in mode DM_SPECS
direct_declarator: in member namespace: used on line 38
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for count in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found count is a basic IDENTIFIER
Lexer FSM: checking id: count with status 0 in mode DM_SPECS
direct_declarator: in member namespace: count on line 39
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for nreg in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found nreg is a basic IDENTIFIER
Lexer FSM: checking id: nreg with status 0 in mode DM_SPECS
direct_declarator: in member namespace: nreg on line 40
Debug: create_declaration_specifiers returned: spec([], int)
end of stand alone declaration specifier as a declaration on line 41
Debug: create_declaration_specifiers returned: spec([], struct(UC___anonstruct____missing_field_name_212, [struct_decl(spec([], struct(Ctl_table)), [ptr_decl(pointer, ctl_table)]), struct_decl(spec([], int), [used]), struct_decl(spec([], int), [count]), struct_decl(spec([], int), [nreg])]))
is_typedef_name: Looking for main in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found main is a basic IDENTIFIER
Lexer FSM: checking id: main with status 0 in mode DM_SPECS
Trying to Pop scope 1 when scope_stack scope_nb is 0
is_typedef_name: Looking for v in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found v is a basic IDENTIFIER
Lexer FSM: checking id: v with status 0 in mode DM_SPECS
is_typedef_name: Looking for __VERIFIER_nondet_int in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found __VERIFIER_nondet_int is a basic IDENTIFIER
Lexer FSM: checking id: __VERIFIER_nondet_int with status 0 in mode DM_DECLS
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for x in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 in mode DM_SPECS
Debug: create_declaration_specifiers returned: spec([], int)
is_typedef_name: Looking for v in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found v is a basic IDENTIFIER
Lexer FSM: checking id: v with status 0 in mode DM_NONE
is_typedef_name: Looking for x in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 in mode DM_NONE
is_typedef_name: Looking for x in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 in mode DM_NONE
Trying to Pop scope 1 when scope_stack scope_nb is 0
is_typedef_name: Looking for x in typedef list
Scope 0:
	proc_handler is a TYPEDEF_NAME
	loff_t is a TYPEDEF_NAME
	ctl_table is a TYPEDEF_NAME
	ssize_t is a TYPEDEF_NAME
	size_t is a TYPEDEF_NAME
	umode_t is a TYPEDEF_NAME
is_typedef_name: not found x is a basic IDENTIFIER
Lexer FSM: checking id: x with status 0 in mode DM_NONE
Debug: create_declaration_specifiers returned: spec([], int)
function parsed
Sikraken from ./bin/call_parser.sh: successfully preprocessed parsing_bugs and ran sikraken_parser.
